<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Grag</title>
<script src="jslib/jquery-2.1.3.js"></script>
<script src="jslib/jquery-ui.js"></script>
<link rel="stylesheet" href="/jslib/jquery-ui.css">
<script src="socket.io/socket.io.js"></script>
<script src="jslib/jquery.toast.min.js"></script> <!-- source: https://github.com/kamranahmedse/jquery-toast-plugin -->  
<script src="https://unpkg.com/smoothscroll-polyfill@0.4.4/dist/smoothscroll.min.js"></script> <!-- source: https://github.com/iamdustan/smoothscroll -->
<link rel="stylesheet" href="/jslib/jquery.toast.min.css">
<link rel="stylesheet" href="grag3-tail.css">
<style>


</style>

<script>

var socket = io.connect('/browser')
var clientId = undefined
var things = {}
var scenarios = {}
var currentScenario = { things: {} }


var showIoTLink = false

var onThingGroupChanged
var groupDefinitions = {}

var iosLastCheckedTime = new Date().getTime()
var iosTimeoutTimerId
function iosTimeoutCheck() {
    if (iosTimeoutTimerId) { // only necessary if this is called more than once at init
        clearTimeout(iosTimeoutTimerId)
        delete iosTimeoutTimerId
    }
    var timeNow = new Date().getTime();
    if (timeNow - iosLastCheckedTime > 5000) {
        location.reload()
    }
    iosLastCheckedTime = timeNow;
    iosTimeoutTimerId = setTimeout(iosTimeoutCheck, 1000);
}

function createGroups() {
    let body = $('body')
    Object.values(groupDefinitions).filter(groupDef => !groupDef.type || groupDef.type == 'box').forEach(groupDef => {
        let box = '<div class="m-4 rounded-xl shadow-2xl border-4 border-solid border-slate-700 space-x-4 ' + groupDef.style + '"> \
        <div class="grid content-start grid-cols-2"><div class="text-2xl font-bold pl-3 pt-2">' + groupDef.name + '</div><div id="group-infobox-' + groupDef.id + '" class="justify-self-end"></div></div> \
    <div id="group-' + groupDef.id + '" class="flex flex-row flex-wrap object-left content-start"></div> \
</div>'
        body.append(box)
        createMoreButton(groupDef)
    })
    Object.values(groupDefinitions).filter(groupDef => groupDef.type == 'modal').forEach(groupDef => {
        createModal(groupDef)
    })
    createInfobox(groupDefinitions['main'])
}

function createModal(def) {
    let box = '\
<div id="' + def.id + '" class="group fixed inset-0 overflow-y-auto hidden"> \
  <div class="flex items-end justify-center min-h-screen pt-4 px-4 pb-20 text-center sm:block sm:p-0"> \
    <div class="fixed inset-0 bg-gray-500 bg-opacity-75 transition-opacity ease-out duration-200 opacity-0 group-target:ease-in group-target:duration-200 group-target:opacity-100" onClick="hideModal()"></div> \
    <span class="hidden sm:inline-block sm:align-middle sm:h-screen" >&#8203;</span> \
    <div class="relative inline-block align-bottom bg-white rounded-lg text-left overflow-hidden shadow-xl transform transition-all sm:my-8 sm:align-middle sm:max-w-lg sm:w-full ease-in duration-200 opacity-0 translate-y-4 sm:translate-y-0 sm:scale-95 group-target:ease-out group-target:duration-200 group-target:opacity-100 group-target:translate-y-0 group-target:sm:scale-100 m-4 rounded-xl shadow-2xl border-4 border-solid border-slate-700 space-x-4 ' + def.style + '"> \
        <div class="text-2xl font-bold pl-3 pt-2">' + def.name + '</div> \
        <div id="group-' + def.id + '" class="flex flex-row flex-wrap object-left content-start"></div> \
    </div> \
  </div> \
</div>'
    let body = $('body')
    body.append(box)
    $('#' + def.id)[0].ontransitionend = (e) => {
        if (window.location.hash.match(/^#?$/)) {
            $('#' + def.id).addClass('hidden')
            console.log('Closed modal', def.id)
        }
    }
    console.log('Created modal dialog for ' + def.id)
//    console.log($('#' + def.id))

// TODO ??
//    createButtonInModal({ id: 'test' })
}

function createInfobox(groupDef) {
    //if (!groupDef.infobox) return
    console.log('Creating infobox for group ' + groupDef.name + ' (' + groupDef.id + ')')
    let infobox = $('#group-infobox-' + groupDef.id)
    if (!infobox[0]) {
        alert('while creating infobox: group ' + groupDef.id + ' not found')
        return
    }
    let box = '<div id="infobox-fence-' + groupDef.id + '" class="mb-1 mt-1 px-1 p-0 mx-0"><div id="infobox-' + groupDef.id + '" class="p-1 rounded-md shadow-lg space-x-4 flex bg-emerald-100" onClick="onThingClicked(event, \'' +  '\')">Temp: xxÂ° / Hum: xx% / Sunset soon</div></div>'
    infobox.append(box)
}

// called from smart.js when a new thing is received
function createThingCb(thing) {
    if (thing.def.render.hidden) return // TODO this 'hidden' is coming from the backend; in other places, hidden is a calculated state - confusing
    console.log('Creating thing ' + thing.def.name + ' (' + thing.id + ') in group ' + thing.def.group)
    let group = $('#group-' + thing.def.group)
    if (!group[0]) {
        alert('thing ' + thing.id + ' group unknown: ' + thing.def.group)
        return
    }
    // class="m-4 mx-4 p-4 max-w-sm mx-auto rounded-xl shadow-lg flex space-x-4 bg-lime-50"
    let box = '<div id="thing-fence-' + thing.id + '" class="mb-4 px-4 p-0 max-w-sm mx-0"><div id="thing-' + thing.id + '" class="p-4 max-w-sm rounded-xl shadow-lg space-x-4 flex bg-lime-50" onClick="onThingClicked(event, \'' + thing.id + '\')">Loading...</div><div class="w-full bg-gray-300 rounded-full h-2.5 dark:bg-gray-700 relative hidden" title="(loading)"><div class="bg-gray-100 h-2.5 rounded-full" style="width: 0%"></div></div></div>'
    group.append(box)
    // set some defaults, if not explicitely defined
    if (!thing.def.link && thing.def.api == 'tasmota') thing.def.link = 'http://' + thing.def.device + '.fritz.box'
    thing.def.togglevalues = { 'ON': 'OFF', 'OFF': 'ON', '': 'ON', ...thing.def.togglevalues }
    
    thing.onChanged = onThingChanged_cbFactory(box)
    thing.onChanged(thing)
    UpdateGroupMoreButton(thing.def.group) // ensures that 'more' is always last
}

function createMoreButton(groupDef) {
    groupDef.showAll = false
    let group = $('#group-' + groupDef.id)
    if (!group[0]) {
        alert('group unknown: ' + groupDef.id)
        return
    }
    let box = '<div id="morebutton-fence-' + groupDef.id + '" class="mb-4 px-4 p-0 max-w-sm mx-0"><div id="morebutton-' + groupDef.id + '" class="p-4 max-w-sm rounded-xl shadow-lg space-x-4 flex bg-lime-50" onClick="onMoreButtonClicked(event, \'' + groupDef.id + '\')">...</div><div class="w-full bg-gray-300 rounded-full h-2.5 dark:bg-gray-700 relative hidden" title="show more"><div class="bg-gray-100 h-2.5 rounded-full" style="width: 0%"></div></div>'
    group.append(box)
    UpdateGroupMoreButton(groupDef.id)
}

function onMoreButtonClicked(event, groupId) {
    let groupDef = groupDefinitions[groupId]
    ChangeGroupShowAll(groupDef, !groupDefinitions[groupId].showAll)
}

function ChangeGroupShowAll(groupDef, showAll) {
    console.log('Show all for group ' + groupDef.id + ' ' + (showAll ? 'enabled' : 'disabled'))
    groupDef.showAll = showAll
    Object.values(things).filter(thing => thing.def.group == groupDef.id).forEach(thing => {
        thing.onChanged(thing)
    })
    UpdateGroupMoreButton(groupDef.id)
}

function UpdateGroupMoreButton(groupId) {
    let groupDef = groupDefinitions[groupId]
    if (!groupDef) return
    let thingsInGroup = Object.values(things).filter(thing => thing.def.group == groupDef.id)
    let hiddenThings = thingsInGroup.filter(thing => thing.def.render.hidden)
    let hideableThings = thingsInGroup.filter(thing => calcIfAutoHidden(thing) && !thing.def.render.hidden)
    let hiddenCount = hiddenThings.length
    let hideableCount = hideableThings.length
    let objFence = $('#morebutton-fence-' + groupDef.id)
    let obj = $('#morebutton-' + groupDef.id)
    if (hiddenCount && hideableCount) {
        obj.text( 'Confused')
        obj.attr('title', hiddenThings.map(thing => 'Show ' + thing.def.name).join('\n') + '\n' + hideableThings.map(thing => 'Hide ' + thing.def.name).join('\n'))
    } else if (hiddenCount) {
        obj.text( 'Show ' + hiddenCount)
        obj.attr('title', hiddenThings.map(thing => 'Show ' + thing.def.name).join('\n'))
    } else if (hideableCount) {
        obj.text( 'Hide ' + hideableCount)
        obj.attr('title', hideableThings.map(thing => 'Hide ' + thing.def.name).join('\n'))
    } else {
        obj.text( '?')
        obj.attr('title', 'This button should be hidden')
    }
    console.log('Group ' + groupDef.id + ' hidden things: ' + hiddenCount)
    if (hiddenCount == 0 && hideableCount == 0) {
        objFence.addClass('hidden')
    } else {
        objFence.removeClass('hidden')
        let group = $('#group-' + groupDef.id)
        group.append(objFence)
    }
}

function onThingClicked(event, thingId, detail = '') {
    let thing = things[thingId]
    if (!thing) return
    console.log('clicked: ' + thing.id + ' ' + detail)
    event.stopPropagation()
    if (detail == 'link') {
        location.href = thing.def.link
        return
    }
    if (!thing.def.render.split || detail == 'icon') {
        let currentValue = thing.def.api == 'mpd' ? thing.value.status.state : thing.def.api == 'onkyo' ? thing.value.power : thing.value
        let action = thing.def.togglevalues[currentValue] ? thing.def.togglevalues[currentValue] : thing.def.togglevalues['']
        console.log('Default action for ' + thingId + ' when value="' + currentValue + '": ' + action)
        socket.emit('things', { id: thing.id, action: action } )
    } else {
        showModal(thingId)
    }
}

// returns true if a thing is hideable, i.e. might be hidden based on status/value
function calcIfHideable(thing) {
    console.log('AUTO', thing.id, thing.def.render.autohide, currentScenario?.hide?.indexOf(thing.id), thing.status)
    if (thing.def.render.autohide) return true
    if (currentScenario?.hide?.indexOf(thing.id) > -1) return true
    return false
}

// returns true if a thing is hideable, alive (except hiddenIfDead), and the value is as the scenario expects it
function calcIfAutoHidden(thing) {
    if (!calcIfHideable(thing)) return false
    if (thing.status == 'dead') return thing.def.render.hiddenIfDead
    return calcScenarioExpectation(thing).asExpected
}
 
// returns true if the current value of the thing is different from the scenario expectation. Dead things return false.
function calcIfDifferentFromScenario(thing) {
    let exp = currentScenario.things[thing.id]
    if (!exp) return false
    if (isObject(exp)) {
        if (isObject(thing.value)) {
            return Object.keys(exp).filter(key => thing.value[key] != exp[key]).length == 0
        } else {
            return thing.value != exp.power
        }
    } else return thing.value != exp
}

function calcScenarioExpectation(thing) {
    if (!currentScenario) {
        // no scenario selected or not yet loaded
        return { asExpected: true, tooltip: '' }
    }
    let exp = currentScenario.things[thing.id]
    if (!exp) return { asExpected: true, tooltip: '' }
    let thingDisplayName = thing.status == 'dead' ? thing.def.name + ' â ' : thing.def.name
    if (isObject(exp)) {
        if (true || isObject(thing.value)) {
console.log('!!!!!!!!!!!! ', exp, thing.value)
            let deepCompare = (value, expectation, prefix = '', expString = [], expString2 = []) => {
                let allRes = true
                Object.keys(expectation).forEach(key => {
                    if (isObject(expectation[key]) && isObject(value[key])) {
                        let { allRes: _allRes, expString: _expString, expString2: _expString2 } = deepCompare(thing.value[key], expectation[key], key + '.')
                        if (!_allRes) allRes = false
                        expString.push(..._expString)
                        expString2.push(..._expString2)
                    } else if (!isObject(expectation[key]) && !isObject(value[key])) {
                        let res = (value[key] == expectation[key]) || (expectation[key] == '' && !(key in value))
                        if (!res) allRes = false
                        expString.push(prefix + key + '=' + expectation[key] + (res ? ' â' : ' â'))
                        if (!res) expString2.push(prefix + key + ' should be ' + expectation[key])
                    } else {
                        allRes = false
                        expString(prefix + key + ': nesting error')
                        expString(prefix + key + ': nesting error')
                    }
                })
                return { allRes, expString, expString2 }
            }
            let { allRes, expString, expString2 } = deepCompare(thing.value, exp)
            return { asExpected: allRes, tooltip: '\n\nScenario: ' + expString.join(' / '), text: thingDisplayName + ' ' + expString2.join(', ') }
        } else {
            // default to 'power'
            let res = (thing.value == exp.power)
            let expString = 'power=' + exp.power + (res ? ' â' : ' â')
            return { asExpected: res, tooltip: '\n\nScenario: ' + expString, text: thingDisplayName + ' should be ' + exp.power }
        }
    } else {
        let res = thing.value == exp
        let expString = exp + (res ? ' â' : ' â')
        return { asExpected: res, tooltip: '\n\nScenario: ' + expString, text: thingDisplayName + ' should be ' + exp }
    }
}

var scenarioExpectationStatus = {}
function updateScenarioExpectationDisplay(thing, scenarioExpectation) {
    if (!currentScenario || !currentScenario.things[thing.id]) return
//    console.log('Things to check for scenario expectations: ' + Object.keys(currentScenario.things).map(t => '"' + t + '"').join(', '))
//    console.log('Known Things: ' + Object.keys(things).map(t => '"' + t + '"').join(', '))
    let unexpectedList = Object.keys(currentScenario.things).map(thingId => things[thingId]).filter(thing => thing.status != 'dead' || !thing.def.render.hiddenIfDead).map(thing => ({ thing: thing, ...calcScenarioExpectation(thing) })).filter(exp => !exp.asExpected).map(expectation =>  expectation.text)
    let deadList = Object.values(things).filter(thing => thing.status == 'dead' && !thing.def.render.hiddenIfDead).filter(thing => !currentScenario.things.hasOwnProperty(thing.id)).map(thing => thing.def.name + ' â ')

    if (unexpectedList.length == 0) {
        if (deadList.length == 0) {
            $('#currentScenarioText').first().html(currentScenario.name + ' â')
            $('#currentScenarioText').first().attr('title', 'Everything as expected')
        } else {
            $('#currentScenarioText').first().html(currentScenario.name + ' â\n<br>' + deadList.join('\n<br>'))
            $('#currentScenarioText').first().attr('title', 'Scenario as expected, some things are unreachable:\n' + deadList.join('\n'))
        }
    } else {
        $('#currentScenarioText').first().html(currentScenario.name + ' â\n<br>' + [...unexpectedList, ...deadList].join('\n<br>'))
        $('#currentScenarioText').first().attr('title', [...unexpectedList, ...deadList].join('\n'))
    }
}

// hides or shows a thing, updating the rest of the UI as well
function hideThing(thing, objFence, hide) {
    if (thing.def.render.hidden == hide) return
    thing.def.render.hidden = hide
    if (hide) objFence.addClass('hidden')
    else objFence.removeClass('hidden')
    console.log((hide ? 'Hiding' : 'Showing') + ' thing ' + thing.id)
    UpdateGroupMoreButton(thing.def.group)
}

function onThingChanged_cbFactory(box) {
    return (thing, diff = null) => {
        let objFence = $('#thing-fence-' + thing.id)
        let obj = $('#thing-' + thing.id)
        if (!obj) return
        console.log('Thing ' + thing.id + ' changed', diff)
        let value = thing.value
        if (thing.def.api == 'mpd') value = thing.value.status ? value = thing.value.status.state : '?'
        let scenarioExpectation = calcScenarioExpectation(thing)
        updateScenarioExpectationDisplay(thing, scenarioExpectation)
        if (calcIfHideable(thing)) {
console.log(thing.def.group)
            let hidden = groupDefinitions[thing.def.group]?.showAll === false && calcIfAutoHidden(thing)
            hideThing(thing, objFence, hidden)
        }
        let bgClass = ''
        obj[0].classList.forEach(cssClass => { if (cssClass.startsWith('bg-') || cssClass.startsWith('border-')) obj.removeClass(cssClass) } ) // remove all previous background & border styles
        switch (thing.status) {
            case 'uninitialized':
                bgClass = 'bg-stone-50'
                value = 'Connecting...'
                break
            case 'alive':
            case 'stale':
            case 'ignored':
                bgClass = value == 'OFF' ? 'bg-lime-50' : value == 'ON' ? 'bg-amber-200' : 'bg-amber-100'
                if (thing.def.api == 'mpd') bgClass = value == 'stop' || value == 'pause' ? 'bg-lime-50' : value == 'play' ? 'bg-amber-200' : 'bg-amber-100'
                if (thing.def.api == 'onkyo') bgClass = value.power == 'OFF' ? 'bg-lime-50' : value.power == 'ON' ? 'bg-amber-200' : 'bg-amber-100'
                if (!scenarioExpectation.asExpected) bgClass += ' border-dashed border-2 border-orange-300'
                break;
            case 'dead':
                bgClass = 'bg-stone-300 border-dashed border-2 border-red-600'
                value = 'unreachable'
                break
            default:
                bgClass = 'bg-red-400'
                value = 'error'
        }
        let tasmotaIcon = ''
        let opacity = ''
        if (showIoTLink) {
            if (thing.def.link) {
//                bgClass = 'bg-sky-200'
                tasmotaIcon = '<a href="' + thing.def.link + '"><img class="w-8" src="img-grag/tasmota-logo.svg" style="cursor:grab;" onClick="onThingClicked(event, \'' + thing.id + '\', \'link\')"></a>'
//                opacity = 'opacity-10'
            } else {
//                bgClass = 'bg-stone-200'
//                opacity = 'opacity-10'
            }
        }
        obj.addClass(bgClass)
        if (thing.status == 'dead') {
            let imgsrc = ''
            if (thing.def.render['icon-dead']) imgsrc = thing.def.render['icon-dead']
            else if (thing.def.render['icon']) imgsrc = thing.def.render['icon']
            else if (thing.def.render['icon-off']) imgsrc = thing.def.render['icon-off']
            else imgsrc = 'fa/lightbulb.svg' // what else to display?
            let onIconclick = ''
            obj[0].innerHTML = '<div class="shrink-0"><img class="h-12 w-20 ' + opacity + '" src="img-grag/' + imgsrc + '" alt="Logo"' + onIconclick + '></div>' +
                '<div class="flow-root inline-block"><div class="text-xl font-medium text-black inline-block">' + thing.def.name + '</div><p class="text-slate-500">' + value + '</p></div>' + tasmotaIcon + 
                ''
            obj.attr('title', scenarioExpectation.tooltip)
        } else if (thing.def.api == 'mpd') {
            let imgsrc = thing.def.render['icon']
            let onIconclick = ' onClick="onThingClicked(event, \'' + thing.id + '\', \'icon\')"'
            let mappedValue = { 'stop': 'Stopped', 'play': 'Playing', 'pause': 'Paused' }[value] ?? 'unknown (' + value + ')'
            obj[0].innerHTML = '<div class="shrink-0"><img class="h-12 w-20' + opacity + '" src="img-grag/' + imgsrc + '" alt="Logo"' + onIconclick + '></div>' +
                '<div><div class="text-xl font-medium text-black">' + thing.def.name + '</div><p class="text-slate-500">' + mappedValue + '</p></div>'
            let errorStr = thing.value.status?.error ? '\n\nError: ' + thing.value.status.error : ''
            let mpdTooltip = mappedValue + '\n' + thing.value.status.Name + '\n' + thing.value.status.Title + '\n\nVolume: ' + thing.value.status.volume + errorStr
            obj.attr('title', mpdTooltip + scenarioExpectation.tooltip)
        } else if (thing.def.api == 'onkyo') {
            let imgsrc = thing.def.render['icon']
            let onIconclick = ' onClick="onThingClicked(event, \'' + thing.id + '\', \'icon\')"'
            obj[0].innerHTML = '<div class="shrink-0"><img class="h-12 w-20' + opacity + '" src="img-grag/' + imgsrc + '" alt="Logo"' + onIconclick + '></div>' +
                '<div><div class="text-xl font-medium text-black">' + thing.def.name + '</div><p class="text-slate-500">' + value.power + '</p></div>'
            obj.attr('title', 'Volume: ' + value.volume + scenarioExpectation.tooltip)
        } else {
            let imgsrc = thing.value == 'OFF' ? 'fa/lightbulb.svg' : 'fa/lightbulb-on.svg'
            let onIconclick = ''
            if (thing.value == 'ON' && thing.def.render['icon-on']) imgsrc = thing.def.render['icon-on']
            else if (thing.value == 'OFF' && thing.def.render['icon-off']) imgsrc = thing.def.render['icon-off']
            else if (thing.def.render['icon']) imgsrc = thing.def.render['icon']
            if (thing.def.render.split) onIconclick = ' onClick="onThingClicked(event, \'' + thing.id + '\', \'icon\')"'
            obj[0].innerHTML = '<div class="shrink-0"><img class="h-12 w-20 ' + opacity + '" src="img-grag/' + imgsrc + '" alt="Logo"' + onIconclick + '></div>' +
                '<div class="flow-root inline-block"><div class="text-xl font-medium text-black inline-block">' + thing.def.name + '</div><p class="text-slate-500">' + value + '</p></div>' + tasmotaIcon + 
                ''
            obj.attr('title', scenarioExpectation.tooltip)
        }
    }
}

var updateAliveCheck_Timer = null
function updateAliveCheck(activateTimer) {
    let consideredDeadMs = 120 * 1000 // TODO: read from backend
    console.log("Updating alive indicators")
    let showhide = null

    if (updateAliveCheck_Timer && !activateTimer) {
        clearInterval(updateAliveCheck_Timer)
        updateAliveCheck_Timer = null
    }
    if (!activateTimer) {
        showhide = (obj) => obj.addClass('hidden')
    }
    if (!updateAliveCheck_Timer && activateTimer) {
        updateAliveCheck_Timer = setInterval(() => { updateAliveCheck(true) }, 1000); 
        showhide = (obj) => obj.removeClass('hidden')
    }

    let now = new Date()
    Object.values(things).forEach(thing => {
        let lastUpdated = new Date(thing.lastUpdated)
        let diff = now - lastUpdated
        let percentage = diff <= consideredDeadMs ? Math.round(100 - diff / consideredDeadMs * 100) : 0
        let obj_fence = $('#thing-fence-' + thing.id)
        let bar = obj_fence.children(':nth-child(2)')
        let filled_bar = bar.children(':first-child')
        filled_bar.css('width', percentage + '%')
        if (thing.lastUpdated) bar.prop('title', percentage + '%' + '\nLast Updated: ' + lastUpdated + '\n' + diff + ' ago')
        else bar.prop('title', 'Never seen online :(')
        if (showhide) showhide(bar)
    })
}

function toggleHideIoT(event) {
    showIoTLink = !showIoTLink
    Object.values(things).forEach(thing => thing.onChanged(thing, {}))
    event.stopPropagation()
}

function showModal(id) {
    $('#' + id).removeClass('hidden'); 
    setTimeout(() => {
        console.log("Show Modal", id)
        location.href = '#' + id
    }, 1)
}

function hideModal() {
    window.location.href = '#'
}

function onload() {
    window.location.href = '#'
    onThingGroupChanged = () => createGroups()
    socket.emit('things', 'retrieveThingGroups')
    socket.emit('things', 'retrieveAll')
    socket.emit('things', 'retrieveScenarios')
    socket.emit('subscribe', 'things')
    socket.emit('subscribe', 'thingScenario')
    updateAliveCheck(false)
    $('#currentScenarioText').first().text('loading...')
    iosTimeoutCheck()
}

</script>

<script src="smart.js"></script>

</head>
<body onload="onload()" class="bg-topography">
<span class="absolute">Scenario: <span id='currentScenarioText'></span></span>

<div class="p-6 min-w-0 mx-auto bg-lime-50 rounded-xl shadow-lg flex my-6 justify-center text-xl font-medium text-black">
    <span onclick="location.href='grag.html'" Title="Go to old Grag">Grag</span>&nbsp;zu Diensten
    <img onclick="toggleHideIoT(event);updateAliveCheck(updateAliveCheck_Timer == null)" src="img-grag/tasmota-logo.svg" style="width:30px;margin-left:30px;cursor:grab;" title="Toggle Tasmota">
    <a href="http://10.20.30.5:3000/d/-okauIf7k/bauhof?orgId=1&from=now-24h&to=now&refresh=1m" style="margin-left:30px;" title="Grafana"><img src="img-grag/grafana-logo.png" style="width:30px;"></a>
    <a href="http://10.20.30.200:8123/dash-main/0" style="margin-left:30px;" title="Home Assistant"><img src="img-grag/hass-logo.png" style="width:30px;height:30px"></a>
    <a href="https://10.20.30.92:8006/" style="margin-left:30px;" title="Proxmox"><img src="img-grag/proxmox-logo.png" style="width:30px;height:30px"></a>
    <a href="http://10.20.30.5:8080/cgi-bin/" style="margin-left:30px;" title="Bitrot"><img src="img-grag/qnap-logo.png" style="width:30px;height:30px"></a>
    <a href="https://grag.fritz.box:8443/" style="margin-left:30px;" title="Unifi"><img src="img-grag/unifi-logo.png" style="width:30px;height:30px"></a>
    <a href="http://10.20.30.5:8086/" style="margin-left:30px;" title="Influxdb"><img src="img-grag/influxdb-logo.png" style="width:30px;height:30px"></a>
    <a href="https://portainer.fritz.box:12320/" style="margin-left:30px;" title="Portainer Shell"><img src="img-grag/influxdb-logo.png" style="width:30px;height:30px"></a>
    <a href="https://portainer.fritz.box:12321/" style="margin-left:30px;" title="Portainer Webmin"><img src="img-grag/influxdb-logo.png" style="width:30px;height:30px"></a>
    <a href="http://portainer.fritz.box:9000/" style="margin-left:30px;" title="Portainer.io"><img src="img-grag/influxdb-logo.png" style="width:30px;height:30px"></a>
</div>

</body></html>
